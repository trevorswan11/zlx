<!DOCTYPE html>
<html lang="en" data-theme="light">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ZLX Language Reference</title>
    <style>
        :root {
            --bg: #ffffff;
            --fg: #111111;
            --accent: #007acc;
            --code-bg: #f0f0f0;
            --border: #ccc;
        }

        [data-theme="dark"] {
            --bg: #121212;
            --fg: #eeeeee;
            --accent: #66b2ff;
            --code-bg: #1e1e1e;
            --border: #444;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: system-ui, sans-serif;
            display: flex;
            height: 100vh;
            overflow: hidden;
            background: var(--bg);
            color: var(--fg);
        }

        nav {
            width: 250px;
            background: var(--bg);
            border-right: 1px solid var(--border);
            padding: 1rem;
            overflow-y: auto;
        }

        nav h2 {
            font-size: 1.2rem;
            margin-top: 0;
        }

        nav a {
            display: block;
            margin: 0.5rem 0;
            color: var(--fg);
            text-decoration: none;
        }

        nav a:hover {
            text-decoration: underline;
        }

        .logo {
            width: 100%;
            height: auto;
            display: block;
            margin-bottom: 1rem;
        }

        button.theme-toggle {
            margin-top: 1rem;
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        main {
            flex: 1;
            padding: 2rem;
            overflow-y: auto;
        }

        section {
            margin-bottom: 4rem;
        }

        section h1 {
            font-size: 1.5rem;
            border-bottom: 1px solid var(--border);
            padding-bottom: 0.3rem;
        }

        code {
            background: var(--code-bg);
            padding: 0em 0.4em;
            border-radius: 4px;
            font-family: monospace;
        }

        pre {
            background: var(--code-bg);
            padding: 1rem;
            overflow-x: auto;
            border-radius: 4px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 1.5rem;
        }

        td {
            border: 1px solid var(--border);
            padding: 0.5rem;
            text-align: center;
            background: var(--code-bg);
            font-family: monospace;
        }
    </style>
</head>

<body>
    <nav>
        <img src="../resources/zlx-logo-v2.png" alt="ZLX Logo" class="logo">
        <h2>Table of Contents</h2>
        <a href="#intro">Introduction</a>
        <a href="#syntax">Syntax</a>
        <a href="#keywords">Keywords</a>
        <a href="#types">Types</a>
        <a href="#functions">Functions</a>
        <a href="#tokens">Tokens</a>

        <button class="theme-toggle" onclick="toggleTheme()">Toggle Theme</button>
    </nav>

    <main>
        <section id="intro">
            <h1>Introduction</h1>
            <p>Welcome to the documentation for <strong>ZLX</strong>. This page covers syntax, types, features, and
                common patterns.</p>
            <p>ZLX has two main modes, interpreting and REPL. You can enter REPL by simply running the binary with no
                command line arguments. If you would like to write ZLX code in a script and interpret it, simply pass
                the path to the script to the binary upon execution.</p>
            <p>ZLX's interpreter has 3 sub-modes: <code>run</code> (default), <code>ast</code>, and <code>dump</code>.
                <code>run</code> is the default parameter passed to the binary, and it does not need to be specified.
                This option parses the source code and interprets it. <code>ast</code> simply runs the parser
                over the input file and checks for any immediate parse errors. This is the equivalent to checking for
                compilation errors in other languages. <code>dump</code> prints the code in the input file with syntax
                highlighting, without running the interpreter. This depends on the ast step, and thus cannot be used if
                there are parse errors in your code. These options should be passed as the first argument (before the
                filepath) if desired. If no option is given, the program defaults to interpreting the file.
            </p>
            <p>ZLX's interpreter also has 2 debug modes: <code>time</code> and <code>-v</code>. <code>time</code> can be
                passed after
                the filepath to give a breakdown of the time each step takes to reach the desired output.
                <code>-v</code> can be passed after either the <code>time</code> argument or directly after the
                filepath. This option prints the verbose output of the parser, displaying a properly indented text
                format of the recursively generated abstract syntax tree.
            </p>
            <p>Here are some examples of common uses of the ZLX binary:</p>
            <pre><code>
zlx                     // Initializes REPL mode
zlx foo.zlx             // Interprets the file foo.zlx, where the filepath is relative to the cwd
zlx run foo.zlx         // Same as the above command
zlx ast foo.zlx         // Parses foo.zlx without interpreting
zlx dump foo.zlx        // Parses and dumps the syntax highlighted content of foo.zlx without interpreting
zlx foo.zlx time -v     // Interprets foo.zlx, timing execution and printing the generated AST
zlx foo.zlx -v time     // Same as the above command
            </code></pre>
        </section>

        <section id="syntax">
            <h1>Syntax</h1>
            <p>Basic syntax was inspired by Go, Python, Rust, and more. You can declare mutable variables using the
                <code>let</code> keyword, or constant variables with the <code>const</code> keyword:
            </p>
            <pre><code>
let x = 42;
const y = 20;
print(x, y); >> 4220
y = 2;                  // Error, cannot reassign to constant
            </code></pre>
            <p>While not in REPL mode, statements must be closed by a semicolon. Using more than one semicolon for a
                given statement is a syntax error and the interpreter will fail.</p>
            <p>While in REPL mode, the interpreter is more forgiving and does not need to consume a semicolon to
                interpret a statement. It is only required to use a semicolon when your input takes up multiple lines.
                You can continue your expression onto the next line by using the <code>\</code> symbol. When the REPL
                system detects this character, it will advance to the next line and display <code>..</code> instead of
                <code>>></code>. This indicates that you can continue your input on the next line.
            </p>
            <p>ZLX supports most common operators found in many languages, including common prefix, postfix, and
                reassignment operators like <code>+=</code> Most of these operators are heavily dependent on the
                underlying type of the operand, but this should not be an issue in most scenarios. To learn more about
                the typing system, read the next section.</p>
        </section>

        <section id="keywords">
            <h1>Reserved Keywords</h1>
            <p>The following keywords are reserved in the ZLX language and cannot be used as identifiers:</p>

            <h2>Language Keywords</h2>
            <table>
                <tr>
                    <td>let</td>
                    <td>const</td>
                    <td>struct</td>
                    <td>new</td>
                    <td>import</td>
                </tr>
                <tr>
                    <td>from</td>
                    <td>fn</td>
                    <td>if</td>
                    <td>else</td>
                    <td>foreach</td>
                </tr>
                <tr>
                    <td>while</td>
                    <td>return</td>
                    <td>break</td>
                    <td>continue</td>
                    <td>typeof</td>
                </tr>
                <tr>
                    <td>delete</td>
                    <td>in</td>
                    <td>true</td>
                    <td>false</td>
                    <td>match</td>
                </tr>
                <tr>
                    <td>nil</td>
                </tr>
            </table>

            <h2>Built-in Functions</h2>
            <table>
                <tr>
                    <td>print</td>
                    <td>println</td>
                    <td>len</td>
                    <td>ref</td>
                    <td>range</td>
                </tr>
                <tr>
                    <td>to_string</td>
                    <td>to_number</td>
                    <td>to_bool</td>
                </tr>
            </table>

            <h2>Built-in Modules</h2>
            <table>
                <tr>
                    <td>array</td>
                    <td>debug</td>
                    <td>fs</td>
                    <td>math</td>
                    <td>path</td>
                </tr>
                <tr>
                    <td>random</td>
                    <td>string</td>
                    <td>sys</td>
                    <td>time</td>
                </tr>
            </table>
        </section>

        <section id="types">
            <h1>Types</h1>
            <p>Type annotations are optional. When used, type annotations don't do anything in the realm of safety
                checks or static typing, but they help some people to feel more comfortable. Underlying types are
                enforced in many operations, but these are inferred when expressions are evaluated. </p>
            <pre><code>
let x: int = 42;
print(x);
            </code></pre>
            <p>By default, all declarations get the "any" type, and can be reassigned within reason (without the const
                keyword). To get the type of any value, use <code>typeof</code> as:</p>
            <pre><code>
let x: int = 42;
print(typeof x); >> int
            </code></pre>
            <p>Typed values are not recommended as they require you to call the builtin <code>detype</code> function
                which returns the underlying value in the type. This builtin does not alter the data in the typed value,
                but instead returns a copy of the stored data.</p>
            <pre><code>
let x: int = 42;
print(detype(x)); >> 42
            </code></pre>
        </section>

        <section id="functions">
            <h1>Functions</h1>
            <p>Functions are declared using <code>fn</code>:</p>
            <pre><code>
fn add(a, b) {
    return a + b;
}
            </code></pre>
        </section>

        <section id="tokens">
            <h1>Token Reference</h1>
            <p>The following are the core tokens and symbols used in ZLX. These are grouped by usage and represent the
                actual syntax users can write. Internal tokens like <code>EOF</code> are omitted.</p>

            <h2>Literals & Identifiers</h2>
            <pre><code>
let flag = true;
if flag {
    println("It is true!");
}

let x = nil;
let name = "ZLX";
let pi = 3.14;
    </code></pre>

            <h2>Grouping & Blocks</h2>
            <pre><code>
print((1 + 2) * 3);

if x > 10 {
    println("Big!");
}

let a = [1, 2, 3];
println(a[1]);
    </code></pre>

            <h2>Assignment, Equality & Logic</h2>
            <pre><code>
let x = 10;
if x == 3 {
    println("Equal");
}

if !done {
    println("Not done");
}

if x >= 10 {
    println("Big enough");
}

if x > 0 && y > 0 {
    println("All positive");
}
    </code></pre>

            <h2>Arithmetic & Bitwise Operators</h2>
            <pre><code>
let area = w * h;

x += 5;

let x = 0;
x++;     // now x is 1

let a = 1 | 2;  // a = 3
    </code></pre>

            <h2>Punctuation & Special Symbols</h2>
            <pre><code>
let x = 10;

let x: int = 3;
struct Point { x: int, y: int }

print(x, y);
let a = [1, 2, 3];

foreach i in 1..5 {
    println(i);
}

let result = match x {
    1 => "one",
    2 => "two",
    _ => "other",
};
    </code></pre>

            <h2>Keywords</h2>
            <pre><code>
let x = 5;
const y = 10;

if x == 5 {
    println("Five");
} else {
    println("Not five");
}

while x < 5 {
    x++;
}

foreach i in array {
    println(i);
}

fn square(x) {
    return x * x;
}

while true {
    if x > 10 {
        break;
    }
    x++;
}

struct Point { x, y }
let p = new Point;

import fs from "fs";

let y = match x {
    1 => "one",
    _ => "other",
};

println(typeof x);

delete x;
    </code></pre>
        </section>


    </main>

    <script>
        const root = document.documentElement;

        function setTheme(theme) {
            root.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);
        }

        function toggleTheme() {
            const current = root.getAttribute('data-theme');
            setTheme(current === 'dark' ? 'light' : 'dark');
        }

        (function applyStoredTheme() {
            const stored = localStorage.getItem('theme');
            if (stored) {
                setTheme(stored);
            } else {
                const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                setTheme(prefersDark ? 'dark' : 'light');
            }
        })();
    </script>
</body>

</html>