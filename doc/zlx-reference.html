<!DOCTYPE html>
<html lang="en" data-theme="light">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ZLX Language Reference</title>
    <style>
        :root {
            --bg: #ffffff;
            --fg: #111111;
            --accent: #007acc;
            --code-bg: #f0f0f0;
            --border: #ccc;
        }

        [data-theme="dark"] {
            --bg: #121212;
            --fg: #eeeeee;
            --accent: #66b2ff;
            --code-bg: #1e1e1e;
            --border: #444;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: system-ui, sans-serif;
            display: flex;
            height: 100vh;
            overflow: hidden;
            background: var(--bg);
            color: var(--fg);
        }

        nav {
            width: 250px;
            background: var(--bg);
            border-right: 1px solid var(--border);
            padding: 1rem;
            overflow-y: auto;
        }

        nav h2 {
            font-size: 1.2rem;
            margin-top: 0;
        }

        nav a {
            display: block;
            margin: 0.5rem 0;
            color: var(--fg);
            text-decoration: none;
        }

        nav a:hover {
            text-decoration: underline;
        }

        .logo {
            width: 100%;
            height: auto;
            display: block;
            margin-bottom: 1rem;
        }

        button.theme-toggle {
            margin-top: 1rem;
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        main {
            flex: 1;
            padding: 2rem;
            overflow-y: auto;
        }

        section {
            margin-bottom: 4rem;
        }

        section h1 {
            font-size: 1.5rem;
            border-bottom: 1px solid var(--border);
            padding-bottom: 0.3rem;
        }

        code {
            background: var(--code-bg);
            padding: 0em 0.4em;
            border-radius: 4px;
            font-family: monospace;
        }

        pre {
            background: var(--code-bg);
            padding: 1rem;
            overflow-x: auto;
            border-radius: 4px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 1.5rem;
        }

        td {
            border: 1px solid var(--border);
            padding: 0.5rem;
            text-align: center;
            background: var(--code-bg);
            font-family: monospace;
        }
    </style>
</head>

<body>
    <nav>
        <!-- <img src="../resources/zlx-logo-v2.png" alt="ZLX Logo" class="logo"> --> <!-- Removed for now to allow single-file sharing-->
        <h2>Table of Contents</h2>
        <a href="#intro">Introduction</a>
        <a href="#syntax">Syntax</a>
        <a href="#keywords">Keywords</a>
        <a href="#types">Types</a>
        <a href="#loops">Loops</a>
        <a href="#structs">Structs</a>
        <a href="#functions">Functions</a>

        <button class="theme-toggle" onclick="toggleTheme()">Toggle Theme</button>
    </nav>

    <main>
        <section id="intro">
            <h1>Introduction</h1>
            <p>Welcome to the documentation for <strong>ZLX</strong>. This page covers syntax, types, features, and
                common patterns.</p>
            <p>ZLX has two main modes, interpreting and REPL. You can enter REPL by simply running the binary with no
                command line arguments. If you would like to write ZLX code in a script and interpret it, simply pass
                the path to the script to the binary upon execution.</p>
            <p>ZLX's interpreter has 3 sub-modes: <code>run</code> (default), <code>ast</code>, and <code>dump</code>.
                <code>run</code> is the default parameter passed to the binary, and it does not need to be specified.
                This option parses the source code and interprets it. <code>ast</code> simply runs the parser
                over the input file and checks for any immediate parse errors. This is the equivalent to checking for
                compilation errors in other languages. <code>dump</code> prints the code in the input file with syntax
                highlighting, without running the interpreter. This depends on the ast step, and thus cannot be used if
                there are parse errors in your code. These options should be passed as the first argument (before the
                filepath) if desired. If no option is given, the program defaults to interpreting the file.
            </p>
            <p>ZLX's interpreter also has 2 debug modes: <code>time</code> and <code>-v</code>. <code>time</code> can be
                passed after
                the filepath to give a breakdown of the time each step takes to reach the desired output.
                <code>-v</code> can be passed after either the <code>time</code> argument or directly after the
                filepath. This option prints the verbose output of the parser, displaying a properly indented text
                format of the recursively generated abstract syntax tree.
            </p>
            <p>Here are some examples of common uses of the ZLX binary:</p>
            <pre><code>
zlx                     // Initializes REPL mode
zlx foo.zlx             // Interprets the file foo.zlx, where the filepath is relative to the cwd
zlx run foo.zlx         // Same as the above command
zlx ast foo.zlx         // Parses foo.zlx without interpreting
zlx dump foo.zlx        // Parses and dumps the syntax highlighted content of foo.zlx without interpreting
zlx foo.zlx time -v     // Interprets foo.zlx, timing execution and printing the generated AST
zlx foo.zlx -v time     // Same as the above command
            </code></pre>
        </section>

        <section id="syntax">
            <h1>Syntax</h1>
            <p>Basic syntax was inspired by Go, Python, Rust, and more. You can declare mutable variables using the
                <code>let</code> keyword, or constant variables with the <code>const</code> keyword:
            </p>
            <pre><code>
let x = 42;
const y = 20;
print(x, y); >> 4220
y = 2;                  // Error, cannot reassign to constant
            </code></pre>
            <p>While not in REPL mode, statements must be closed by a semicolon. Using more than one semicolon for a
                given statement is a syntax error and the interpreter will fail.</p>
            <p>While in REPL mode, the interpreter is more forgiving and does not need to consume a semicolon to
                interpret a statement. It is only required to use a semicolon when your input takes up multiple lines.
                You can continue your expression onto the next line by using the <code>\</code> symbol. When the REPL
                system detects this character, it will advance to the next line and display <code>..</code> instead of
                <code>>></code>. This indicates that you can continue your input on the next line.
            </p>
            <p>ZLX supports most common operators found in many languages, including common prefix, postfix, and
                reassignment operators like <code>+=</code> Most of these operators are heavily dependent on the
                underlying type of the operand, but this should not be an issue in most scenarios. To learn more about
                the typing system, read the next section.</p>
        </section>

        <section id="keywords">
            <h1>Reserved Keywords</h1>
            <p>The following keywords are reserved in the ZLX language and cannot be used as identifiers:</p>

            <h2>Language Keywords</h2>
            <table>
                <tr>
                    <td>let</td>
                    <td>const</td>
                    <td>struct</td>
                    <td>new</td>
                    <td>import</td>
                </tr>
                <tr>
                    <td>from</td>
                    <td>fn</td>
                    <td>if</td>
                    <td>else</td>
                    <td>foreach</td>
                </tr>
                <tr>
                    <td>while</td>
                    <td>return</td>
                    <td>break</td>
                    <td>continue</td>
                    <td>typeof</td>
                </tr>
                <tr>
                    <td>delete</td>
                    <td>in</td>
                    <td>true</td>
                    <td>false</td>
                    <td>match</td>
                </tr>
                <tr>
                    <td>nil</td>
                </tr>
            </table>

            <h2>Built-in Functions</h2>
            <table>
                <tr>
                    <td>print</td>
                    <td>println</td>
                    <td>len</td>
                    <td>ref</td>
                    <td>range</td>
                </tr>
                <tr>
                    <td>to_string</td>
                    <td>to_number</td>
                    <td>to_bool</td>
                </tr>
            </table>

            <h2>Built-in Modules</h2>
            <table>
                <tr>
                    <td>array</td>
                    <td>debug</td>
                    <td>fs</td>
                    <td>math</td>
                    <td>path</td>
                </tr>
                <tr>
                    <td>random</td>
                    <td>string</td>
                    <td>sys</td>
                    <td>time</td>
                </tr>
            </table>
        </section>

        <section id="types">
            <h1>Types</h1>
            <p>Type annotations are optional. When used, type annotations don't do anything in the realm of safety
                checks or static typing, but they help some people to feel more comfortable. Underlying types are
                enforced in many operations, but these are inferred when expressions are evaluated. </p>
            <pre><code>
let x: int = 42;
print(x);
            </code></pre>
            <p>By default, all declarations get the "any" type, and can be reassigned within reason (without the const
                keyword). To get the type of any value, use <code>typeof</code> as:</p>
            <pre><code>
let x: int = 42;
print(typeof x); >> int
            </code></pre>
            <p>Typed values are not recommended as they require you to call the builtin <code>detype</code> function
                which returns the underlying value in the type. This builtin does not alter the data in the typed value,
                but instead returns a copy of the stored data.</p>
            <pre><code>
let x: int = 42;
print(detype(x)); >> 42
            </code></pre>
        </section>

        <section id="loops">
            <h1>Loops</h1>
            <p>ZLX has two types of loops, foreach loops and while loops. A foreach loop allows you to loop through an
                iterable set of elements, specifically an array. You can iterate over a predefined array, or you can use
                a range expression to loop over an anonymous array. Anonymous arrays are created using the
                <code>..</code> operator as: <code>start..end</code>. With this notation, an array starting at
                <code>start</code> and ending at <code>end - 1</code> will be generated. In other words, the array will
                be of length <code>end - start</code>. You can also index into the array by using the
                syntax: <code>foreach value, index in array</code>. If you are interested in creating an array with a
                defined start and end value, but with a step value that is not 1, then see the <code>range</code>
                builtin function. The following examples show proper use of a foreach loop in zlx:
            </p>
            <pre><code>
foreach val in 0..3 {
    println(val);       // Loops through the array: [0, 1, 2]
}
                
let nums = [1, 2, 3];
foreach val, i in nums {
    println("" + (val + 1) + " @ index " + i);
}
            </code></pre>
            <p>While loops in zlx are much less involved, simply taking a condition as its argument. This condition is
                not automatically coerced into a bool, so if you would like to do the C-style <code>while 1...</code>,
                then you should look to the builtin function <code>to_bool</code>. A while loop will run until the
                condition is violated, or until a break or return signal is reached. Both foreach and while loops
                support nested break, continue, and return statements to provide control over loop behavior. These
                statements work the same as in any other modern language. Below are some examples of valid while loops
                in zlx:</p>
            <pre><code>
let i = 0;
while i < 3 {           // Loops 3 total times
    println(i);
    i = i + 1;
}

i = 0;
while i < 6 {
    if i == 3 {
        i = i + 1;
        continue;       // Skips 3
    }
    println(i);
    i = i + 1;
}

i = 0;
while i < 100 {
    println(i);
    i = i + 1;
    if (i == 3) {
        break;          // Quits at 3
    }
}
            </code></pre>
        </section>

        <section id="structs">
            <h1>Structs</h1>
            <p>Structs in zlx are basically classes without inheritance. There is no concept of </p>
        </section>

        <section id="functions">
            <h1>Functions</h1>
            <p>Functions are declared using <code>fn</code>:</p>
            <pre><code>
fn add(a, b) {
    return a + b;
}
            </code></pre>
            <p>They can be declared without any type declarations as seen above, or with types for variables and the
                return type. Ultimately, the inclusion of type annotations in function declarations does not do anything
                for the way interpreting works. A function with type declarations might look like:</p>
            <pre><code>
fn add(a: int, b: int): int {
    const res = a + b;
    res;
}
println(add(5, 10));
            </code></pre>
            <p>Functions in zlx are first-class, meaning they can be passed as parameters and bound to variables freely.
                Functions can also be returned from other functions. They may be created inside the function, but you
                must be careful not to violate closures. Some examples:</p>
            <p></p>
            <pre><code>
struct Greeter {
    let name: string;

    fn ctor(name: string) {
        this.name = name;
    }

    fn greet() {
        println("Hello, " + this.name);
    }
}

fn repeat(func: function, times: number) {
    foreach _ in 0..times {
        func();
    }
}

let g = new Greeter("Ziggy");
repeat(g.greet, 3);
            </code></pre>
            <p>The above code is valid, creating a struct called person with name Ziggy, and passing the greet function
                of the Greeter class to a function that runs it times number of times. Similar to the way this is
                structured, you could assign g.greet to a variable, and pass that variable as the function argument.
                This is perfectly valid zlx code.</p>
            <pre><code>
fn builder(x) {
    fn add(y) {
        return x + y;
    }
    return add;
}

let func = builder(23);
println(func(4));
            </code></pre>
            <p>The above code will fail as the add function does not capture the parameter x declared in the builder
                function. This is not safety checked and will cause an immediate failure on the backend. You cannot
                handle this type of error without changing the source code of zlx. I do not want to do this yet!</p>
        </section>

    </main>

    <script>
        const root = document.documentElement;

        function setTheme(theme) {
            root.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);
        }

        function toggleTheme() {
            const current = root.getAttribute('data-theme');
            setTheme(current === 'dark' ? 'light' : 'dark');
        }

        (function applyStoredTheme() {
            const stored = localStorage.getItem('theme');
            if (stored) {
                setTheme(stored);
            } else {
                const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                setTheme(prefersDark ? 'dark' : 'light');
            }
        })();
    </script>
</body>

</html>