<!DOCTYPE html>
<html lang="en" data-theme="light">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ZLX Language Reference</title>
    <style>
        :root {
            --bg: #ffffff;
            --fg: #111111;
            --accent: #007acc;
            --code-bg: #f0f0f0;
            --border: #ccc;
        }

        [data-theme="dark"] {
            --bg: #121212;
            --fg: #eeeeee;
            --accent: #66b2ff;
            --code-bg: #1e1e1e;
            --border: #444;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: system-ui, sans-serif;
            display: flex;
            height: 100vh;
            overflow: hidden;
            background: var(--bg);
            color: var(--fg);
        }

        nav {
            width: 250px;
            background: var(--bg);
            border-right: 1px solid var(--border);
            padding: 1rem;
            overflow-y: auto;
        }

        nav h2 {
            font-size: 1.2rem;
            margin-top: 0;
        }

        nav a {
            display: block;
            margin: 0.5rem 0;
            color: var(--fg);
            text-decoration: none;
        }

        nav a:hover {
            text-decoration: underline;
        }

        .logo {
            width: 100%;
            height: auto;
            display: block;
            margin-bottom: 1rem;
        }

        button.theme-toggle {
            margin-top: 1rem;
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        main {
            flex: 1;
            padding: 2rem;
            overflow-y: auto;
        }

        section {
            margin-bottom: 4rem;
        }

        section h1 {
            font-size: 1.5rem;
            border-bottom: 1px solid var(--border);
            padding-bottom: 0.3rem;
        }

        code {
            background: var(--code-bg);
            padding: 0em 0.4em;
            border-radius: 4px;
            font-family: monospace;
        }

        pre {
            background: var(--code-bg);
            padding: 1rem;
            overflow-x: auto;
            border-radius: 4px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 1.5rem;
        }

        td {
            border: 1px solid var(--border);
            padding: 0.5rem;
            text-align: center;
            background: var(--code-bg);
            font-family: monospace;
        }

        nav ul {
            padding-left: 1.5em;
            margin-top: 0.2em;
        }
    </style>
</head>

<body>
    <nav>
        <!-- <img src="../resources/ZLX-logo-v2.png" alt="ZLX Logo" class="logo"> -->
        <!-- Removed for now to allow single-file sharing-->
        <h2>Table of Contents</h2>
        <a href="#intro">Introduction</a>
        <a href="#syntax">Syntax</a>
        <a href="#keywords">Keywords</a>
        <a href="#types">Types</a>
        <a href="#loops">Loops</a>
        <a href="#objects">Objects</a>
        <a href="#structs">Structs</a>
        <a href="#functions">Functions</a>
        <a href="#patterns">Pattern Matching</a>
        <div>
            <a href="#builtins">Builtins</a>
            <ul>
                <li>
                    <a href="#array">array</a>
                    <ul>
                        <li><a href="#array-slice">slice</a></li>
                        <li><a href="#array-join">join</a></li>
                    </ul>
                </li>

                <li>
                    <a href="#debug">debug</a>
                    <ul>
                        <li><a href="#debug-assert">assert</a></li>
                        <li><a href="#debug-assert_equal">assert_equal</a></li>
                        <li><a href="#debug-assert_not_equal">assert_not_equal</a></li>
                        <li><a href="#debug-fail">fail</a></li>
                    </ul>
                </li>

                <li>
                    <a href="#fs">fs</a>
                    <ul>
                        <li><a href="#fs-read">read</a></li>
                        <li><a href="#fs-write">write</a></li>
                        <li><a href="#fs-exists">exists</a></li>
                        <li><a href="#fs-remove">remove</a></li>
                        <li><a href="#fs-list">list</a></li>
                        <li><a href="#fs-list_all_files">list_all_files</a></li>
                        <li><a href="#fs-mkdir">mkdir</a></li>
                        <li><a href="#fs-rmdir">rmdir</a></li>
                        <li><a href="#fs-rm">rm</a></li>
                        <li><a href="#fs-copy">copy</a></li>
                        <li><a href="#fs-rename">rename</a></li>
                        <li><a href="#fs-is_dir">is_dir</a></li>
                        <li><a href="#fs-read_lines">read_lines</a></li>
                        <li><a href="#fs-touch">touch</a></li>
                        <li><a href="#fs-append">append</a></li>
                    </ul>
                </li>

                <li>
                    <a href="#math">math</a>
                    <ul>
                        <li><a href="#math-sqrt">sqrt</a></li>
                        <li><a href="#math-abs">abs</a></li>
                        <li><a href="#math-sin">sin</a></li>
                        <li><a href="#math-cos">cos</a></li>
                        <li><a href="#math-tan">tan</a></li>
                        <li><a href="#math-asin">asin</a></li>
                        <li><a href="#math-acos">acos</a></li>
                        <li><a href="#math-atan">atan</a></li>
                        <li><a href="#math-atan2">atan2</a></li>
                        <li><a href="#math-log">log</a></li>
                        <li><a href="#math-log10">log10</a></li>
                        <li><a href="#math-exp">exp</a></li>
                        <li><a href="#math-floor">floor</a></li>
                        <li><a href="#math-ceil">ceil</a></li>
                        <li><a href="#math-round">round</a></li>
                        <li><a href="#math-pow">pow</a></li>
                        <li><a href="#math-min">min</a></li>
                        <li><a href="#math-max">max</a></li>
                    </ul>
                </li>

                <li>
                    <a href="#path">path</a>
                    <ul>
                        <li><a href="#path-join">join</a></li>
                        <li><a href="#path-basename">basename</a></li>
                        <li><a href="#path-dirname">dirname</a></li>
                        <li><a href="#path-extname">extname</a></li>
                        <li><a href="#path-stem">stem</a></li>
                        <li><a href="#path-is_absolute">is_absolute</a></li>
                        <li><a href="#path-is_relative">is_relative</a></li>
                        <li><a href="#path-normalize">normalize</a></li>
                        <li><a href="#path-split">split</a></li>
                    </ul>
                </li>

                <li>
                    <a href="#random">random</a>
                    <ul>
                        <li><a href="#random-rand">rand</a></li>
                        <li><a href="#random-randint">randint</a></li>
                        <li><a href="#random-choice">choice</a></li>
                    </ul>
                </li>

                <li>
                    <a href="#string">string</a>
                    <ul>
                        <li><a href="#string-upper">upper</a></li>
                        <li><a href="#string-lower">lower</a></li>
                        <li><a href="#string-slice">slice</a></li>
                        <li><a href="#string-find">find</a></li>
                        <li><a href="#string-replace">replace</a></li>
                        <li><a href="#string-split">split</a></li>
                        <li><a href="#string-ltrim">ltrim</a></li>
                        <li><a href="#string-rtrim">rtrim</a></li>
                        <li><a href="#string-trim">trim</a></li>
                        <li><a href="#string-contains">contains</a></li>
                        <li><a href="#string-starts_with">starts_with</a></li>
                        <li><a href="#string-ends_with">ends_with</a></li>
                    </ul>
                </li>

                <li>
                    <a href="#sys">sys</a>
                    <ul>
                        <li><a href="#sys-args">args</a></li>
                        <li><a href="#sys-getenv">getenv</a></li>
                        <li><a href="#sys-setenv">setenv</a></li>
                        <li><a href="#sys-unsetenv">unsetenv</a></li>
                        <li><a href="#sys-run">run</a></li>
                        <li><a href="#sys-input">input</a></li>
                    </ul>
                </li>

                <li>
                    <a href="#time">time</a>
                    <ul>
                        <li><a href="#time-now">now</a></li>
                        <li><a href="#time-millis">millis</a></li>
                        <li><a href="#time-sleep">sleep</a></li>
                        <li><a href="#time-sleepMs">sleep_ms</a></li>
                        <li><a href="#time-timestamp">timestamp</a></li>
                        <li><a href="#time-constants">Time Constants</a></li>
                    </ul>
                </li>

                <li>
                    <a href="#csv">csv</a>
                    <ul>
                        <li><a href="#csv-read">read(path)</a></li>
                        <li><a href="#csv-write">write(path, csv_string)</a></li>
                        <li><a href="#csv-append">append(path, csv_string)</a></li>
                        <li><a href="#csv-parse">parse(text)</a></li>
                        <li><a href="#csv-stringify">stringify(array)</a></li>
                    </ul>
                </li>

                <li>
                    <a href="#json">json</a>
                    <ul>
                        <li><a href="#json-parse">parse(text)</a></li>
                        <li><a href="#json-stringify">stringify(value)</a></li>
                    </ul>
                </li>

                <li>
                    <a href="#stat">stat</a>
                    <ul>
                        <li><a href="#stat-mean">mean</a></li>
                        <li><a href="#stat-median">median</a></li>
                        <li><a href="#stat-mode">mode</a></li>
                        <li><a href="#stat-min">min</a></li>
                        <li><a href="#stat-max">max</a></li>
                        <li><a href="#stat-range">range</a></li>
                        <li><a href="#stat-variance">variance</a></li>
                        <li><a href="#stat-stddev">stddev</a></li>
                        <li><a href="#stat-covariance">covariance</a></li>
                        <li><a href="#stat-correlation">correlation</a></li>
                        <li><a href="#stat-linear_regression">linear_regression</a></li>
                        <li><a href="#stat-z_score">z_score</a></li>
                        <li><a href="#stat-normal_pdf">normal_pdf</a></li>
                        <li><a href="#stat-normal_cdf">normal_cdf</a></li>
                        <li><a href="#stat-constants">Stat Constants</a></li>
                    </ul>
                </li>

                <li>
                    <a href="#builtin-functions">Functions</a>
                    <ul>
                        <li><a href="#print">print</a></li>
                        <li><a href="#println">println</a></li>
                        <li><a href="#len">len</a></li>
                        <li><a href="#ref">ref</a></li>
                        <li><a href="#deref">deref</a></li>
                        <li><a href="#detype">detype</a></li>
                        <li><a href="#raw">raw</a></li>
                        <li><a href="#range">range</a></li>
                        <li><a href="#to_string">to_string</a></li>
                        <li><a href="#to_number">to_number</a></li>
                        <li><a href="#to_bool">to_bool</a></li>
                        <li><a href="#to_ascii">to_ascii</a></li>
                        <li><a href="#from_ascii">from_ascii</a></li>
                        <li><a href="#format">format</a></li>
                        <li><a href="#zip">zip</a></li>
                    </ul>
                </li>

                <li>
                    <a href="#dsa">Data Structures</a>
                    <ul>
                        <li><a href="#std_array_list">ArrayList</a></li>
                        <li><a href="#std_set">HashSet</a></li>
                        <li><a href="#std_map">HashMap</a></li>
                        <li><a href="#std_adjacency_list">AdjacencyList</a></li>
                        <li><a href="#std_graph">Graph</a></li>
                        <li><a href="#std_adjacency_matrix">AdjacencyMatrix</a></li>
                        <li><a href="#std_heap">PriorityQueue</a></li>
                        <li><a href="#std_treap">Treap</a></li>
                        <li><a href="#std_stack">Stack</a></li>
                        <li><a href="#std_queue">Queue</a></li>
                        <li><a href="#std_list">LinkedList</a></li>
                        <li><a href="#std_deque">Deque</a></li>
                        <li><a href="#std_vector">Vector</a></li>
                        <li><a href="#std_matrix">Matrix</a></li>
                    </ul>
                </li>
            </ul>
        </div>

        <button class="theme-toggle" onclick="toggleTheme()">Toggle Theme</button>
    </nav>

    <main>
        <section id="intro">
            <h1>Introduction</h1>
            <p>Welcome to the documentation for ZLX. This page covers syntax, types, features, and
                common patterns.</p>
            <p>ZLX has two main modes, interpreting and REPL. You can enter REPL by simply running the binary with no
                command line arguments. If you would like to write ZLX code in a script and interpret it, simply pass
                the path to the script to the binary upon execution.</p>
            <p>ZLX's interpreter has 3 sub-modes: <code>run</code> (default), <code>ast</code>, and <code>dump</code>.
                <code>run</code> is the default parameter passed to the binary, and it does not need to be specified.
                This option parses the source code and interprets it. <code>ast</code> simply runs the parser
                over the input file and checks for any immediate parse errors. This is the equivalent to checking for
                compilation errors in other languages. <code>dump</code> prints the code in the input file with syntax
                highlighting, without running the interpreter. This depends on the ast step, and thus cannot be used if
                there are parse errors in your code. These options should be passed as the first argument (before the
                filepath) if desired. If no option is given, the program defaults to interpreting the file.
            </p>
            <p>ZLX's interpreter also has 2 debug modes: <code>time</code> and <code>-v</code>. <code>time</code> can be
                passed after
                the filepath to give a breakdown of the time each step takes to reach the desired output.
                <code>-v</code> can be passed after either the <code>time</code> argument or directly after the
                filepath. This option prints the verbose output of the parser, displaying a properly indented text
                format of the recursively generated abstract syntax tree.
            </p>
            <p>Here are some examples of common uses of the ZLX binary:</p>
            <pre><code>
ZLX                     // Initializes REPL mode
ZLX foo.ZLX             // Interprets the file foo.ZLX, where the filepath is relative to the cwd
ZLX run foo.ZLX         // Same as the above command
ZLX ast foo.ZLX         // Parses foo.ZLX without interpreting
ZLX dump foo.ZLX        // Parses and dumps the syntax highlighted content of foo.ZLX without interpreting
ZLX foo.ZLX time -v     // Interprets foo.ZLX, timing execution and printing the generated AST
ZLX foo.ZLX -v time     // Same as the above command
            </code></pre>
        </section>

        <section id="syntax">
            <h1>Syntax</h1>
            <p>Basic syntax was inspired by Go, Python, Rust, and more. You can declare mutable variables using the
                <code>let</code> keyword, or constant variables with the <code>const</code> keyword:
            </p>
            <pre><code>
let x = 42;
const y = 20;
print(x, y); >> 4220
y = 2;                  // Error, cannot reassign to constant
            </code></pre>
            <p>While not in REPL mode, statements must be closed by a semicolon. Using more than one semicolon for a
                given statement is a syntax error and the interpreter will fail.</p>
            <p>While in REPL mode, the interpreter is more forgiving and does not need to consume a semicolon to
                interpret a statement. It is only required to use a semicolon when your input takes up multiple lines.
                You can continue your expression onto the next line by using the <code>\</code> symbol. When the REPL
                system detects this character, it will advance to the next line and display <code>..</code> instead of
                <code>>></code>. This indicates that you can continue your input on the next line.
            </p>
            <p>ZLX supports most common operators found in many languages, including common prefix, postfix, and
                reassignment operators like <code>+=</code> Most of these operators are heavily dependent on the
                underlying type of the operand, but this should not be an issue in most scenarios. To learn more about
                the typing system, read the next section. ZLX also supports discarding values using the "_" symbol. It
                cannot be used after the 'let' or 'const' keywords, and variables assigned to it are not tracked in any
                scope.</p>
        </section>

        <section id="keywords">
            <h1>Reserved Keywords</h1>
            <p>The following keywords are reserved in the ZLX language and cannot be used as identifiers:</p>

            <h2>Language Keywords</h2>
            <table>
                <tr>
                    <td>let</td>
                    <td>const</td>
                    <td>struct</td>
                    <td>new</td>
                    <td>import</td>
                </tr>
                <tr>
                    <td>from</td>
                    <td>fn</td>
                    <td>if</td>
                    <td>else</td>
                    <td>foreach</td>
                </tr>
                <tr>
                    <td>for</td>
                    <td>while</td>
                    <td>return</td>
                    <td>break</td>
                    <td>continue</td>
                </tr>
                <tr>
                    <td>typeof</td>
                    <td>delete</td>
                    <td>in</td>
                    <td>true</td>
                    <td>false</td>
                </tr>
                <tr>
                    <td>match</td>
                    <td>nil</td>
                </tr>
            </table>

            <h2>Built-in Functions</h2>
            <table>
                <tr>
                    <td>print</td>
                    <td>println</td>
                    <td>len</td>
                    <td>ref</td>
                    <td>range</td>
                </tr>
                <tr>
                    <td>to_string</td>
                    <td>to_number</td>
                    <td>to_bool</td>
                </tr>
            </table>

            <h2>Built-in Modules</h2>
            <table>
                <tr>
                    <td>array</td>
                    <td>debug</td>
                    <td>fs</td>
                    <td>math</td>
                    <td>path</td>
                </tr>
                <tr>
                    <td>random</td>
                    <td>string</td>
                    <td>sys</td>
                    <td>time</td>
                </tr>
            </table>
        </section>

        <section id="types">
            <h1>Types</h1>
            <p>Type annotations are optional. When used, type annotations don't do anything in the realm of safety
                checks or static typing, but they help some people to feel more comfortable. Underlying types are
                enforced in many operations, but these are inferred when expressions are evaluated. </p>
            <pre><code>
let x: int = 42;
print(x);
            </code></pre>
            <p>By default, all declarations get the "any (current_type)" type, and can be reassigned within reason
                (without the const keyword). The current type corresponds to the interpreters current understanding of
                the value. The type of a value is represented by a pair of values with the second entry being a narrower
                context of the first entry.To get the type of any value, use <code>typeof</code> as:</p>
            <pre><code>
let x: int = 42;
print(typeof x); >> Pair{"typed_val", "int"}
            </code></pre>
            <p>Typed values are not recommended as they require you to call the builtin <code>detype</code> function
                which returns the underlying value in the type. This builtin does not alter the data in the typed value,
                but instead returns a copy of the stored data.</p>
            <pre><code>
let x: int = 42;
print(detype(x)); >> 42
            </code></pre>
            <p>Instances of structs in the standard library are inherently typed and can be used with the typeof
                operator. You cannot detype these data structures.</p>
            <h2>Strings</h2>
            <p>Strings in ZLX are somewhat unique. They can be declared only with double quotes, and multiline strings
                can be declared using 3 backticks. Multiline strings will capture all newline tokens starting from the
                end of the first triplet of backticks and ending with the start of the ending triplet.</p>
            <pre><code>
let s = ```This is
a multiline
string```;
println(s);
            </code></pre>
        </section>

        <section id="loops">
            <h1>Loops</h1>
            <p>ZLX has two types of loops, foreach loops and while loops. A foreach loop allows you to loop through an
                iterable set of elements, specifically an array. You can iterate over a predefined array, or you can use
                a range expression to loop over an anonymous array. Anonymous arrays are created using the
                <code>..</code> operator as: <code>start..end</code>. With this notation, an array starting at
                <code>start</code> and ending at <code>end - 1</code> will be generated. In other words, the array will
                be of length <code>end - start</code>. You can also index into the array by using the
                syntax: <code>foreach value, index in array</code>. If you are interested in creating an array with a
                defined start and end value, but with a step value that is not 1, then see the <code>range</code>
                builtin function. <code>for</code> is also a valid token, but is an alias for a foreach loop. The
                following examples show proper use of a foreach loop in ZLX:
            </p>
            <pre><code>
foreach val in 0..3 {
    println(val);       // Loops through the array: [0, 1, 2]
}
                
let nums = [1, 2, 3];
foreach val, i in nums {
    println("" + (val + 1) + " @ index " + i);
}
            </code></pre>
            <p>While loops in ZLX are much less involved, simply taking a condition as its argument. This condition is
                not automatically coerced into a bool, so if you would like to do the C-style <code>while 1...</code>,
                then you should look to the builtin function <code>to_bool</code>. A while loop will run until the
                condition is violated, or until a break or return signal is reached. Both foreach and while loops
                support nested break, continue, and return statements to provide control over loop behavior. These
                statements work the same as in any other modern language. Below are some examples of valid while loops
                in ZLX:</p>
            <pre><code>
let i = 0;
while i < 3 {           // Loops 3 total times
    println(i);
    i = i + 1;
}

i = 0;
while i < 6 {
    if i == 3 {
        i = i + 1;
        continue;       // Skips 3
    }
    println(i);
    i = i + 1;
}

i = 0;
while i < 100 {
    println(i);
    i = i + 1;
    if (i == 3) {
        break;          // Quits at 3
    }
}
            </code></pre>
        </section>

        <section id="objects">
            <h1>Objects</h1>
            <p>Objects in ZLX are weakly typed groups of data. They can be thought of as named tuples in other
                languages. You can access the values in an objects by using the <code>.</code> operator or by using a
                computed expression, which is defined by the <code>obj[name]</code> syntax. With this syntax, the name
                must be a string. This type of expression makes the object act as a pseudo lookup table, but
                interpretation will fail if the property doesn't exist. An example declaration of an object and its two
                ways of accessing data are shown here:</p>
            <pre><code>
let obj1 = { foo: 123, bar: "baz" };
println(obj1.foo);
println(obj1["bar"]);
            </code></pre>
        </section>

        <section id="structs">
            <h1>Structs</h1>
            <p>Structs in ZLX are basically classes without inheritance. There is no concept of OOP in ZLX, and structs
                should only be used as helpful ways to organize data and have common functions for certain types. They
                are declared using the <code>struct</code> keyword, and you can reference data inside a struct through
                its functions using the <code>this</code> keyword. You can call functions on structs using typical call
                notation as seen in virtually all languages. All fields declared in a struct are public, and there is no
                way to access this behavior. You can access fields by using the <code>.</code> operator or by using a
                computed expression as you would on a basic object. An example struct with example interactions with its
                field and functions can be seen here:
            </p>
            <pre><code>
struct Greeter {
    let name: string;

    fn ctor(name: string) {
        this.name = name;
    }

    fn greet() {
        println("Hello, " + this.name);
    }
}

let g = new Greeter("Ziggy");
println(g.name);                // Ziggy
println(g["__struct_name"]);    // Greeter
println(g["name"]);             // Ziggy
g.greet();                      // Hello, Ziggy
            </code></pre>
        </section>

        <section id="functions">
            <h1>Functions</h1>
            <p>Functions are declared using <code>fn</code>:</p>
            <pre><code>
fn add(a, b) {
    return a + b;
}
            </code></pre>
            <p>They can be declared without any type declarations as seen above, or with types for variables and the
                return type. Ultimately, the inclusion of type annotations in function declarations does not do anything
                for the way interpreting works. A function with type declarations might look like:</p>
            <pre><code>
fn add(a: int, b: int): int {
    const res = a + b;
    res;
}
println(add(5, 10));
            </code></pre>
            <p>Functions in ZLX are first-class, meaning they can be passed as parameters and bound to variables freely.
                Functions can also be returned from other functions. They may be created inside the function, but you
                must be careful not to violate closures. Some examples:</p>
            <p></p>
            <pre><code>
struct Greeter {
    let name: string;

    fn ctor(name: string) {
        this.name = name;
    }

    fn greet() {
        println("Hello, " + this.name);
    }
}

fn repeat(func: function, times: number) {
    foreach _ in 0..times {
        func();
    }
}

let g = new Greeter("Ziggy");
repeat(g.greet, 3);
            </code></pre>
            <p>The above code is valid, creating a struct called person with name Ziggy, and passing the greet function
                of the Greeter class to a function that runs it times number of times. Similar to the way this is
                structured, you could assign g.greet to a variable, and pass that variable as the function argument.
                This is perfectly valid ZLX code.</p>
            <pre><code>
fn builder(x) {
    fn add(y) {
        return x + y;
    }
    return add;
}

let func = builder(23);
println(func(4));
            </code></pre>
            <p>The above code will fail as the add function does not capture the parameter x declared in the builder
                function. This is not safety checked and will cause an immediate failure on the backend. You cannot
                handle this type of error without changing the source code of ZLX. I do not want to do this yet!</p>
        </section>

        <section id="patterns">
            <h1>Pattern Matching</h1>
            <p>Pattern matching in ZLX works very similar to how it does in languages like rust and zig. In ZLX, pattern
                matching can be used as a statement that invokes a set of instructions based on the state of a variable,
                or it can be used as an expression used for assignment to a variable based on the switched value. You
                can use the <code>_</code> token as an else block that catches all unspecified cases. Each case and its
                corresponding statement must be connected by the arrow operator (<code>=></code>). The two common uses
                for match statements can be seen here:</p>
            <pre><code>
// Match Statement
let x = 3;
match x {
    1 => println("one");
    2 => println("two");
    3 => {
        print("three ");
        println("more");
    },
    _ => println("default");
}                               // three more

// Match Expression
let x = 3;
let y = match x {
    3 => 4,
    _ => 100,
};

println(y);                     // 4
            </code></pre>
        </section>

        <section id="builtins">
            <h1>Builtins</h1>
            <p>Builtin modules are objects of functions and variables that can be imported into any ZLX file using the
                <code>import</code> keyword followed by the module name. While this is required for modules, builtin
                functions are included by default and can be accessed anywhere at any time. As seen in the keywords
                section of this doc, builtin functions and builtin module names are all reserved keywords and cannot be
                used as identifiers. When invoking a builtin module function, the module will tell you if your function
                call is incorrect, but these docs can be used for a surface level understanding. For now, a lot of this
                documentation will be very sparse as I am lazy! ChatGPT was used to create these documentation 'stubs'.
                For example usage of these modules, see the <code>examples/builtins</code> folder. The builtin functions
                can be seen spread out over all examples.
            </p>
            <!-- Array Module Docs -->
            <h2 id="array">array</h2>
            <h3 id="array-slice">slice(arr, start, end)</h3>
            <p>Returns a subarray starting at <code>start</code> (inclusive) and ending at <code>end</code> (exclusive).
                The resulting slice is a new array. Throws an error if the indices are invalid or out of bounds.</p>

            <h3 id="array-join">join(arr, delim)</h3>
            <p>Returns a string of the array's values separated by <code>delim</code>.</p>

            <!-- Debug Module Docs -->
            <h2 id="debug">debug</h2>
            <p>Each of these functions optionally accepts a message string as the last argument. If provided, the
                message is displayed when the assertion fails. These tools are primarily used in testing and debugging
                to catch logical errors early.</p>

            <h3 id="debug-assert">assert(condition, message?)</h3>
            <p>Throws an error if <code>condition</code> is false. Optionally prints <code>message</code> if the
                assertion fails. This is useful for enforcing program invariants during development or testing.</p>

            <h3 id="debug-assert_equal">assert_equal(expected, actual, message?)</h3>
            <p>Throws an error if <code>expected</code> and <code>actual</code> are not equal. Optionally prints
                <code>message</code> on failure. This is commonly used in unit tests to check correctness.
            </p>

            <h3 id="debug-assert_not_equal">assert_not_equal(a, b, message?)</h3>
            <p>Throws an error if <code>a</code> and <code>b</code> are equal. Optionally prints <code>message</code> on
                failure. Useful for testing that two values differ.</p>

            <h3 id="debug-fail">fail(message?)</h3>
            <p>Unconditionally triggers a failure. Optionally prints <code>message</code>. This can be used to mark code
                that should never be reached, or to deliberately trigger test failures.</p>

            <!-- Fs Module Docs -->
            <h2 id="fs">fs</h2>
            <h3 id="fs-read">read(path)</h3>
            <p>Reads the contents of the file at <code>path</code> and returns it as a string. Throws an error if the
                file does not exist or cannot be opened.</p>

            <h3 id="fs-write">write(path, text)</h3>
            <p>Writes the string <code>text</code> to the file at <code>path</code>, overwriting the file if it already
                exists. Creates the file if it does not exist.</p>

            <h3 id="fs-exists">exists(path)</h3>
            <p>Returns <code>true</code> if the file or directory at <code>path</code> exists, otherwise returns
                <code>false</code>.
            </p>

            <h3 id="fs-remove">remove(path)</h3>
            <p>Deletes the file or directory at <code>path</code>. If the target is a non-empty directory, this will
                fail unless handled recursively. Alias of <code>rm</code>.</p>

            <h3 id="fs-list">list(path)</h3>
            <p>Returns an array of names of entries (files and directories) in the given directory <code>path</code>.
                This is a non-recursive listing. <code>ls</code> is an alias for this.</p>

            <h3 id="fs-list_all_files">list_all_files(path)</h3>
            <p>Recursively returns an array of all file paths within the directory <code>path</code>, including files in
                nested subdirectories. <code>lsa</code> is an alias for this.</p>

            <h3 id="fs-mkdir">mkdir(path)</h3>
            <p>Creates a new directory at <code>path</code>. If parent directories do not exist, an error is thrown
                unless explicitly handled.</p>

            <h3 id="fs-rmdir">rmdir(path)</h3>
            <p>Removes the empty directory at <code>path</code>. Will throw an error if the directory is not empty.</p>

            <h3 id="fs-rm">rm(path)</h3>
            <p>Alias of <code>remove</code>. Removes a file or directory at the given path.</p>

            <h3 id="fs-copy">copy(src, dest)</h3>
            <p>Copies the file from <code>src</code> to <code>dest</code>. The destination will be overwritten if it
                already exists. Directories are not supported.</p>

            <h3 id="fs-rename">rename(old_path, new_path)</h3>
            <p>Moves or renames a file or directory from <code>old_path</code> to <code>new_path</code>. If
                <code>new_path</code> already exists, it will be overwritten. <code>move</code> is an alias for this.
            </p>

            <h3 id="fs-is_dir">is_dir(path)</h3>
            <p>Returns <code>true</code> if the path points to a directory, otherwise returns <code>false</code>.</p>

            <h3 id="fs-read_lines">read_lines(path)</h3>
            <p>Reads the file at <code>path</code> and returns an array of lines as strings. Throws an error if the file
                cannot be opened.</p>

            <h3 id="fs-touch">touch(path)</h3>
            <p>Creates an empty file at <code>path</code> if it does not exist. If the file already exists, its
                modification timestamp is updated.</p>

            <h3 id="fs-append">append(path, text)</h3>
            <p>Appends the string <code>text</code> to the end of the file at <code>path</code>. Creates the file if it
                does not already exist.</p>

            <!-- Math Module Docs -->
            <h2 id="math">math</h2>
            <h3 id="math-sqrt">sqrt(x)</h3>
            <p>Returns the square root of <code>x</code>. The input must be a non-negative number.</p>

            <h3 id="math-abs">abs(x)</h3>
            <p>Returns the absolute value of <code>x</code>, stripping any negative sign.</p>

            <h3 id="math-sin">sin(x)</h3>
            <p>Returns the sine of <code>x</code>, where <code>x</code> is interpreted as radians.</p>

            <h3 id="math-cos">cos(x)</h3>
            <p>Returns the cosine of <code>x</code>, where <code>x</code> is in radians.</p>

            <h3 id="math-tan">tan(x)</h3>
            <p>Returns the tangent of <code>x</code>, where <code>x</code> is in radians.</p>

            <h3 id="math-asin">asin(x)</h3>
            <p>Returns the arc-sine of <code>x</code>, in radians. The input must be within the range [-1, 1].</p>

            <h3 id="math-acos">acos(x)</h3>
            <p>Returns the arc-cosine of <code>x</code>, in radians. The input must be within the range [-1, 1].</p>

            <h3 id="math-atan">atan(x)</h3>
            <p>Returns the arc-tangent of <code>x</code>, in radians. The result lies in the range [-π/2, π/2].</p>

            <h3 id="math-atan2">atan2(y, x)</h3>
            <p>Returns the arc-tangent of <code>y / x</code>, considering the quadrant of the point (x, y). The result
                is in radians.</p>

            <h3 id="math-log">log(x)</h3>
            <p>Returns the natural logarithm of <code>x</code>, i.e., the logarithm base <code>e</code>.</p>

            <h3 id="math-log10">log10(x)</h3>
            <p>Returns the base-10 logarithm of <code>x</code>.</p>

            <h3 id="math-exp">exp(x)</h3>
            <p>Returns Euler's number <code>e</code> raised to the power of <code>x</code>.</p>

            <h3 id="math-floor">floor(x)</h3>
            <p>Rounds <code>x</code> down to the largest integer less than or equal to <code>x</code>.</p>

            <h3 id="math-ceil">ceil(x)</h3>
            <p>Rounds <code>x</code> up to the smallest integer greater than or equal to <code>x</code>.</p>

            <h3 id="math-round">round(x)</h3>
            <p>Rounds <code>x</code> to the nearest integer. Halfway values are rounded away from zero.</p>

            <h3 id="math-pow">pow(base, exponent)</h3>
            <p>Returns <code>base</code> raised to the power of <code>exponent</code> (i.e., base<sup>exponent</sup>).
            </p>

            <h3 id="math-min">min(a, b)</h3>
            <p>Returns the smaller of the two numbers <code>a</code> and <code>b</code>.</p>

            <h3 id="math-max">max(a, b)</h3>
            <p>Returns the larger of the two numbers <code>a</code> and <code>b</code>.</p>

            <!-- Path Module Docs -->
            <h2 id="path">path</h2>
            <h3 id="path-join">join(...segments)</h3>
            <p>Joins multiple path <code>segments</code> into a single path string using the appropriate
                platform-specific separator (e.g., <code>/</code> or <code>\</code>). Handles empty segments and
                redundant slashes gracefully.</p>

            <h3 id="path-basename">basename(path)</h3>
            <p>Returns the final component of the given <code>path</code>. This is typically the file or directory name
                at the end of the path.</p>

            <h3 id="path-dirname">dirname(path)</h3>
            <p>Returns the directory portion of the given <code>path</code>, excluding the last component. Useful for
                extracting the parent directory.</p>

            <h3 id="path-extname">extname(path)</h3>
            <p>Returns the file extension from <code>path</code>, including the leading dot (e.g., <code>".txt"</code>).
                If the file has no extension, returns an empty string.</p>

            <h3 id="path-stem">stem(path)</h3>
            <p>Returns the file name without its extension from <code>path</code>. For example, given
                <code>"file.txt"</code>, returns <code>"file"</code>.
            </p>

            <h3 id="path-is_absolute">is_absolute(path)</h3>
            <p>Returns <code>true</code> if the given <code>path</code> is an absolute path, meaning it starts from the
                root of the filesystem.</p>

            <h3 id="path-is_relative">is_relative(path)</h3>
            <p>Returns <code>true</code> if the given <code>path</code> is relative to the current working directory.
                Returns <code>false</code> for absolute paths.</p>

            <h3 id="path-normalize">normalize(path)</h3>
            <p>Returns a cleaned-up version of <code>path</code> by resolving <code>.</code> (current directory),
                <code>..</code> (parent directory), and removing redundant separators.
            </p>

            <h3 id="path-split">split(path)</h3>
            <p>Splits <code>path</code> into an array of its individual components, such as directories and the file
                name. Does not resolve absolute or relative semantics.</p>

            <!-- Random Module Docs -->
            <h2 id="random">random</h2>
            <h3 id="random-rand">rand()</h3>
            <p>Returns a random floating-point number in the range <code>[0, 1)</code>. This is useful for probabilistic
                branching, scaling, or seeding.</p>

            <h3 id="random-randint">randint(min, max)</h3>
            <p>Returns a random integer between <code>min</code> and <code>max</code>, inclusive. Both bounds must be
                integers, and <code>min</code> must be less than or equal to <code>max</code>.</p>

            <h3 id="random-choice">choice(array)</h3>
            <p>Returns a random element from a non-empty <code>array</code>. Throws an error if the array is empty.
                Useful for sampling or randomized selection.</p>

            <!-- String Module Docs -->
            <h2 id="string">string</h2>
            <h3 id="string-upper">upper(str)</h3>
            <p>Returns a new string with all alphabetic characters in <code>str</code> converted to uppercase.
                Non-letter characters are unaffected.</p>

            <h3 id="string-lower">lower(str)</h3>
            <p>Returns a new string with all alphabetic characters in <code>str</code> converted to lowercase.</p>

            <h3 id="string-slice">slice(str, start, end)</h3>
            <p>Returns a substring of <code>str</code> from index <code>start</code> (inclusive) to <code>end</code>
                (exclusive). Indices must be within the string bounds.</p>

            <h3 id="string-find">find(str, substr)</h3>
            <p>Searches <code>str</code> for the first occurrence of <code>substr</code> and returns its starting index.
                Returns <code>-1</code> if not found.</p>

            <h3 id="string-replace">replace(str, target, replacement)</h3>
            <p>Returns a copy of <code>str</code> with all occurrences of <code>target</code> replaced by
                <code>replacement</code>.
            </p>

            <h3 id="string-split">split(str, delimiter)</h3>
            <p>Splits <code>str</code> into an array of substrings, using <code>delimiter</code> as the separator.
                Returns an array of strings.</p>

            <h3 id="string-ltrim">ltrim(str)</h3>
            <p>Removes leading whitespace characters from <code>str</code>. Does not affect internal
                spacing.</p>

            <h3 id="string-rtrim">rtrim(str)</h3>
            <p>Removes trailing whitespace characters from <code>str</code>. Does not affect internal
                spacing.</p>

            <h3 id="string-trim">trim(str)</h3>
            <p>Removes leading and trailing whitespace characters from <code>str</code>. Does not affect internal
                spacing.</p>

            <h3 id="string-contains">contains(str, substr)</h3>
            <p>Returns <code>true</code> if <code>substr</code> appears anywhere within <code>str</code>, otherwise
                returns <code>false</code>.</p>

            <h3 id="string-starts_with">starts_with(str, prefix)</h3>
            <p>Returns <code>true</code> if <code>str</code> starts with <code>prefix</code>, otherwise
                returns <code>false</code>.</p>

            <h3 id="string-ends_with">ends_with(str, suffix)</h3>
            <p>Returns <code>true</code> if <code>str</code> ends with <code>suffix</code>, otherwise
                returns <code>false</code>.</p>

            <!-- Sys module Docs -->
            <h2 id="sys">sys</h2>
            <h3 id="sys-args">args()</h3>
            <p>Returns an array of strings representing the command-line arguments passed to the program. The first
                argument is typically the script name or path.</p>

            <h3 id="sys-getenv">getenv(name)</h3>
            <p>Returns the value of the environment variable named <code>name</code> as a string. Returns
                <code>null</code> if the variable is not defined in the current environment.
            </p>

            <h3 id="sys-setenv">setenv(name, value)</h3>
            <p>Sets or updates the environment variable <code>name</code> to the string <code>value</code> for the
                current process. This change is not persistent beyond the process lifetime.</p>

            <h3 id="sys-unsetenv">unsetenv(name)</h3>
            <p>Removes the environment variable <code>name</code> from the current process's environment. Subsequent
                calls to <code>getenv(name)</code> will return <code>null</code>.</p>

            <h3 id="sys-run">run(cmds)</h3>
            <p>Executes a subprocess using a string representing <code>cmds</code>. Returns the standard
                output of the command on success, or returns std error on failure. Equivalent to spawning a shell
                command.
            </p>

            <h3 id="sys-input">input(prompt)</h3>
            <p>Prints the <code>prompt</code> string and waits for user input from standard input. Returns the line of
                text entered by the user as a string. Input is read until a newline is encountered.</p>

            <!-- Time Module Docs -->
            <h2 id="time">time</h2>
            <h3 id="time-now">now()</h3>
            <p>Returns the current high-resolution system time in nanoseconds as an integer. Useful for benchmarking or
                fine-grained profiling. The reference point is unspecified and may vary across systems.</p>

            <h3 id="time-millis">millis()</h3>
            <p>Returns the number of milliseconds elapsed since an arbitrary fixed point, such as program start or
                system boot. Often used for timing logic that doesn't need absolute wall time.</p>

            <h3 id="time-sleep">sleep(seconds)</h3>
            <p>Pauses program execution for the specified number of <code>seconds</code>. Fractional values (e.g.,
                <code>0.5</code>) are supported for sub-second sleeps.
            </p>

            <h3 id="time-sleepMs">sleep_ms(milliseconds)</h3>
            <p>Suspends execution for the specified number of <code>milliseconds</code>. Equivalent to
                <code>sleep(ms / 1000)</code>, but with clearer intent for short waits.
            </p>

            <h3 id="time-timestamp">timestamp()</h3>
            <p>Returns the current Unix timestamp in seconds, representing the number of seconds since January 1, 1970
                (UTC). Useful for logging, file naming, or expiration logic.</p>

            <h3 id="time-constants">Time Constants</h3>
            <p>The following time constants can be accessed from the time module. These are directly pulled from the zig
                standard library.</p>
            <table>
                <tr>
                    <td>ns_per_us</td>
                    <td>ns_per_ms</td>
                    <td>ns_per_s</td>
                    <td>ns_per_min</td>
                    <td>ns_per_hour</td>
                    <td>ns_per_day</td>
                    <td>ns_per_week</td>
                </tr>
                <tr>
                    <td>us_per_ms</td>
                    <td>us_per_s</td>
                    <td>us_per_min</td>
                    <td>us_per_hour</td>
                    <td>us_per_day</td>
                    <td>us_per_week</td>
                </tr>
                <tr>
                    <td>ms_per_s</td>
                    <td>ms_per_min</td>
                    <td>ms_per_hour</td>
                    <td>ms_per_day</td>
                    <td>ms_per_week</td>
                </tr>
                <tr>
                    <td>s_per_min</td>
                    <td>s_per_hour</td>
                    <td>s_per_day</td>
                    <td>s_per_week</td>
                </tr>
            </table>

            <!-- CSV Module Docs -->
            <h2 id="csv">csv</h2>
            <h3 id="csv-read">read(path)</h3>
            <p>Reads a CSV file from the specified file <code>path</code> and parses its content into a nested array of
                strings. Each line becomes a row, and each comma-separated entry becomes a cell.</p>

            <h3 id="csv-write">write(path, csv_string)</h3>
            <p>Writes the provided <code>csv_string</code> to a file at the specified <code>path</code>. The string
                should be formatted with stringify before passing to the file, or should be formatted in a csv style
                beforehand. In essence, this is the same as <code>fs.write</code>. If the file exists, it is
                overwritten. Automatically creates parent directories if needed.</p>

            <h3 id="csv-append">append(path, csv_string)</h3>
            <p>Appends the provided <code>csv_string</code> to the file at <code>path</code>. Does not overwrite the
                existing file. Creates the file if it does not exist.</p>

            <h3 id="csv-parse">parse(text)</h3>
            <p>Parses a CSV-formatted string into an array of rows, where each row is an array of strings. Empty lines
                are ignored. Whitespace is trimmed.</p>

            <h3 id="csv-stringify">stringify(array)</h3>
            <p>Converts a nested array of strings into a CSV-formatted string. Each subarray becomes a row, and each
                element is separated by commas. Supports <code>string</code>, <code>number</code>, <code>boolean</code>,
                and <code>nil</code> as cell types.</p>

            <!-- JSON Module Docs -->
            <h2 id="json">json</h2>
            <h3 id="json-parse">parse(text)</h3>
            <p>Parses the JSON-formatted string <code>text</code> and returns the corresponding ZLX value. Supports all
                standard JSON types: <code>null</code>, <code>boolean</code>, <code>number</code>, <code>string</code>,
                <code>array</code>, and <code>object</code>. Throws an error if the input is not valid JSON.
            </p>

            <h3 id="json-stringify">stringify(value)</h3>
            <p>Converts a ZLX value into a JSON-formatted string. Supports serializing <code>string</code>,
                <code>number</code>, <code>boolean</code>, <code>nil</code>, <code>array</code>, and <code>object</code>
                types. Throws an error if the input contains unsupported types such as functions or class instances.
            </p>

            <!-- Stat Module Docs -->
            <h2 id="stat">stat</h2>
            <p>The <code>stat</code> module provides functions for basic and advanced statistical computations. It
                supports population and sample variants where relevant. Use <code>stat.population</code> or
                <code>stat.sample</code> as a flag argument where applicable.
            </p>

            <h3 id="stat-mean">mean(array)</h3>
            <p>Returns the arithmetic mean of the numeric array.</p>

            <h3 id="stat-median">median(array)</h3>
            <p>Returns the median value of the numeric array. If the array has even length, the average of the middle
                two values is returned.</p>

            <h3 id="stat-mode">mode(array)</h3>
            <p>Returns the most frequent value in the numeric array. Returns <code>nil</code> if there is no mode (e.g.,
                uniform data).</p>

            <h3 id="stat-min">min(array)</h3>
            <p>Returns the minimum value in the numeric array.</p>

            <h3 id="stat-max">max(array)</h3>
            <p>Returns the maximum value in the numeric array.</p>

            <h3 id="stat-range">range(array)</h3>
            <p>Returns the difference between the maximum and minimum values in the numeric array.</p>

            <h3 id="stat-variance">variance(array, flag)</h3>
            <p>Returns the variance of the array. The second argument must be <code>stat.population</code> or
                <code>stat.sample</code>.
            </p>

            <h3 id="stat-stddev">stddev(array, flag)</h3>
            <p>Returns the standard deviation of the array. The second argument must be <code>stat.population</code> or
                <code>stat.sample</code>.
            </p>

            <h3 id="stat-covariance">covariance(arrayX, arrayY, flag)</h3>
            <p>Returns the covariance of the two numeric arrays. The third argument specifies
                <code>stat.population</code> or <code>stat.sample</code>. Both arrays must have the same length.
            </p>

            <h3 id="stat-correlation">correlation(arrayX, arrayY, flag)</h3>
            <p>Returns the Pearson correlation coefficient between the two numeric arrays. The third argument specifies
                <code>stat.population</code> or <code>stat.sample</code>.
            </p>

            <h3 id="stat-linear_regression">linear_regression(arrayX, arrayY, flag)</h3>
            <p>Performs linear regression on the data and returns an object with keys <code>slope</code>,
                <code>intercept</code>, and <code>r_squared</code>. The third argument specifies
                <code>stat.population</code> or <code>stat.sample</code>.
            </p>

            <h3 id="stat-z_score">z_score(x, mean, stddev)</h3>
            <p>Returns the z-score of a value <code>x</code> given its mean and standard deviation.</p>

            <h3 id="stat-normal_pdf">normal_pdf(x)</h3>
            <p>Returns the probability density of <code>x</code> in the standard normal distribution.</p>

            <h3 id="stat-normal_pdf-3">normal_pdf(x, mean, stddev)</h3>
            <p>Returns the probability density of <code>x</code> under a normal distribution with the given
                <code>mean</code> and <code>stddev</code>.
            </p>

            <h3 id="stat-normal_cdf">normal_cdf(x)</h3>
            <p>Returns the cumulative distribution value of <code>x</code> in the standard normal distribution.</p>

            <h3 id="stat-normal_cdf-3">normal_cdf(x, mean, stddev)</h3>
            <p>Returns the cumulative distribution value of <code>x</code> under a normal distribution with the given
                <code>mean</code> and <code>stddev</code>.
            </p>

            <h3 id="stat-constants">Stat Constants</h3>
            <p>
                <code>stat.population = 0.0</code><br>
                <code>stat.sample = 1.0</code><br>
                Used to distinguish between population and sample variants in applicable functions.
            </p>

            <!-- Builtin Function Docs -->
            <h2 id="builtin-functions">Functions</h2>
            <p>The builtin functions found in ZLX implement reasonably verbose error messages that can be used to guide
                their usage, but this section can be used for clarity.</p>

            <h3 id="print">print</h3>
            <p>The <code>print</code> takes in a variable number of values, and prints them as is with no delimiters
                between arguments. As long as the backend of the language is up to date, all values should implement
                the print function in some way and can be passed as an argument to this function.</p>

            <h3 id="println">println</h3>
            <p>The <code>println</code> function is nearly identical to the print function, but print each argument
                separated by a new
                line token.</p>

            <h3 id="len">len</h3>
            <p>The len <code>function</code> returns the length of a string or array. This is self-explanatory</p>
            <h3 id="ref">ref</h3>
            <p>The <code>ref</code> function takes in any value and packs it into a heap allocated value. This is a copy
                of the original value, and does not make the input value an actual reference. There is no practical
                reason to use this function.</p>

            <h3 id="deref">deref</h3>
            <p>The <code>deref</code> function takes in a reference and returns the underlying value stored on the heap.
                This is a copy of the value and does not alter the input.</p>

            <h3 id="detype">detype</h3>
            <p>The <code>detype</code> function takes in a typed value and returns the raw data underneath. This is
                useful for functions that cannot operate on typed values, as they contain two types of data.</p>

            <h3 id="raw">raw</h3>
            <p>The <code>raw</code> function takes in a nested typed value or reference and returns the raw data
                underneath. This is useful for functions that cannot operate on typed values or references, as they
                contain multiple types of data.</p>

            <h3 id="range">range</h3>
            <p>The <code>range</code> expression is similar to the <code>..</code> operator discussed earlier. This
                function starts at the start index and goes to (including) the end index. It increments by the step,
                returning an array. Step must be a signed value. The way this function is called is by using
                <code>range(start, end, step)</code>. This can be particularly useful for creating custom arrays for
                foreach expressions.
            </p>

            <h3 id="to_string">to_string</h3>
            <p>The <code>to_string</code> function takes in any value and returns its string representation. This is
                self-explanatory.</p>

            <h3 id="to_number">to_number</h3>
            <p>The <code>to_number</code> function takes in any value and returns its number representation. This works
                similar to parse builtins in other languages, and wil fail if the value is not a string.</p>

            <h3 id="to_bool">to_bool</h3>
            <p>The <code>to_bool</code> function takes in any value and coerces it into a bool. Most types are
                considered to be truthy and will return true, but others have specific behavior. Booleans can be passed
                into this function but are not converted for obvious reasons. Numbers are true if they are strictly
                positive. Strings are true if they are non-empty. The same applied for arrays. References are true if
                their underlying value is true. The same is true for typed values. Nil values are false. As mentioned
                earlier, all other values are true.
            </p>

            <h3 id="to_ascii">to_ascii</h3>
            <p>The <code>to_ascii</code> function takes a single-character string and returns its ASCII code as a
                number. The input must be exactly one character long and within the ASCII range (0-127). For example,
                <code>to_ascii("A")</code> returns <code>65</code>.
            </p>

            <h3 id="from_ascii">from_ascii</h3>
            <p>The <code>from_ascii</code> function takes a number representing an ASCII code (0-127) and returns the
                corresponding character as a string. For example, <code>from_ascii(65)</code> returns <code>"A"</code>.
            </p>

            <h3 id="format">format</h3>
            <p>The <code>format</code> function takes in a string template followed by arguments to bake into the
                template. The function will not crash if insufficient arguments are given. Arguments in the string are
                indicated to be templates by using "{}". An example of this is <code>format("x = {}", 2);</code></p>

            <h3 id="zip">zip</h3>
            <p>The <code>zip</code> function takes multiple arrays and combines them element-wise into a single array of
                tuples. Each tuple contains the corresponding elements from the input arrays at the same index. The
                length of the result is equal to the shortest input array. For example,
                <code>zip([1, 2], ["a", "b", "c"])</code> produces <code>[[1, "a"], [2, "b"]]</code>.
            </p>

        </section>

        <section id="dsa">
            <h2>Standard Library Data Structures</h2>
            <p>
                ZLX includes a rich set of built-in data structures, such as arrays, sets, maps, and graphs. They are
                accessible via simple imports like <code>import array;</code> or <code>import hashmap;</code>. Each
                structure is instantiated using <code>new</code> and provides standard methods (e.g.,
                <code>insert</code>, <code>remove</code>, <code>size</code>, <code>clear</code>) via dot notation. These
                data structures are fully integrated into the language and designed to be intuitive, memory-safe, and
                efficient for general-purpose use.
            </p>
            <h3 id="std_array_list">ArrayList</h3>
            <p><strong>Summary:</strong> A dynamic, resizable array similar to Python's `list` or JavaScript's `Array`,
                implemented using Zig's manual memory model. This is similar to the array module, but acts as an object
                instead of a function interface.</p>
            <p><strong>Constructor:</strong><br><code>let arr = new array_list();</code></p>
            <p><strong>Methods:</strong></p>
            <ul>
                <li><code>arr.push(value)</code>: Appends a value to the end.</li>
                <li><code>arr.insert(index, value)</code>: Inserts a value at a given index.</li>
                <li><code>arr.remove(index)</code>: Removes and returns the value at the given index.</li>
                <li><code>arr.set(index, value)</code>: Overwrites the value at the given index.</li>
                <li><code>arr.pop()</code>: Removes and returns the last value.</li>
                <li><code>arr.get(index)</code>: Returns the value at the given index.</li>
                <li><code>arr.clear()</code>: Empties the array.</li>
                <li><code>arr.empty()</code>: Returns true if the array is empty.</li>
                <li><code>arr.size()</code>: Returns the size of the array.</li>
                <li><code>arr.items()</code>: Returns the items in the array as an iterable array.</li>
                <li><code>arr.str()</code>: Returns the string representation of the array.</li>
            </ul>
            <p><strong>Example:</strong></p>
            <pre><code>
let a = new array_list();
a.push(10);
a.insert(0, 5);
let val = a.get(1);  // val == 10
a.remove(1);
            </code></pre>

            <h3 id="std_set">HashSet</h3>
            <p><strong>Summary:</strong> A collection of unique values, similar to sets in Python, implemented using
                hashing.</p>
            <p><strong>Constructor:</strong><br><code>let s = new set();  // or: new set([1, 2, 3])</code></p>
            <p><strong>Methods:</strong></p>
            <ul>
                <li><code>s.insert(value)</code>: Inserts a value into the set.</li>
                <li><code>s.remove(value)</code>: Removes a value from the set.</li>
                <li><code>s.contains(value)</code>: Returns true if the value is in the set.</li>
                <li><code>s.clear()</code>: Empties the set.</li>
                <li><code>s.size()</code>: Returns the number of elements.</li>
                <li><code>s.empty()</code>: Returns true if the set is empty.</li>
                <li><code>s.items()</code>: Returns the items in the set as an iterable array.</li>
                <li><code>s.str()</code>: Returns the string representation of the set.</li>
            </ul>
            <p><strong>Example:</strong></p>
            <pre><code>
let s = new set();
s.insert("a");
s.insert("b");
s.remove("a");
let has_b = s.contains("b");
            </code></pre>

            <h3 id="std_map">HashMap</h3>
            <p><strong>Summary:</strong> A key-value mapping structure, similar to Python's `dict` or JavaScript's
                `Object`.</p>
            <p><strong>Constructor:</strong><br><code>let m = new map();</code></p>
            <p><strong>Methods:</strong></p>
            <ul>
                <li><code>m.put(key, value)</code>: Associates a key with a value.</li>
                <li><code>m.get(key)</code>: Retrieves the value associated with the key.</li>
                <li><code>m.remove(key)</code>: Deletes the key-value pair.</li>
                <li><code>m.contains(key)</code>: Checks if the key exists.</li>
                <li><code>m.clear()</code>: Removes all key-value pairs.</li>
                <li><code>m.size()</code>: Returns the number of pairs.</li>
                <li><code>m.empty()</code>: Returns true if the map is empty.</li>
                <li><code>m.items()</code>: Returns the items in the map as an iterable array.</li>
                <li><code>m.str()</code>: Returns the string representation of the map.</li>
            </ul>
            <p><strong>Example:</strong></p>
            <pre><code>
let m = new map();
m.put("a", 1);
let x = m.get("a");
m.remove("a");
            </code></pre>

            <h3 id="std_adjacency_list">AdjacencyList</h3>
            <p><strong>Summary:</strong> A graph structure using adjacency lists. Keys represent nodes; values are lists
                of neighbors.</p>
            <p><strong>Constructor:</strong><br><code>let g = new adjacency_list();</code></p>
            <p><strong>Methods:</strong></p>
            <ul>
                <li><code>g.add_edge(from, to)</code>: Adds a directed edge.</li>
                <li><code>g.get_neighbors(node)</code>: Returns the neighbor list.</li>
                <li><code>g.contains(node)</code>: Returns true if the node exists.</li>
                <li><code>g.empty()</code>: Returns true if the adjacency list is empty.</li>
                <li><code>g.clear()</code>: Removes all nodes and edges.</li>
                <li><code>g.size()</code>: Returns number of nodes.</li>
                <li><code>g.str()</code>: Returns the string representation of the adjacency list.</li>
            </ul>
            <p><strong>Example:</strong></p>
            <pre><code>
let g = new adjacency_list();
g.add_edge(1, 2);
g.add_edge(1, 3);
let n = g.get_neighbors(1);
            </code></pre>

            <h3 id="std_graph">Graph</h3>
            <p><strong>Summary:</strong> An alias for AdjacencyList for now: structured graph APIs.</p>
            <p><strong>Constructor:</strong><br><code>let g = new graph();</code></p>
            <p><strong>Methods:</strong></p>
            <ul>
                <li>Same as adjacency_list</li>
            </ul>
            <p><strong>Example:</strong></p>
            <pre><code>
let g = new graph();
g.add_edge("a", "b");
            </code></pre>

            <h3 id="std_adjacency_matrix">AdjacencyMatrix</h3>
            <p><strong>Summary:</strong> A graph structure backed by a 2D matrix where each node is stored as an index.
                Supports unweighted edges only.</p>
            <p><strong>Constructor:</strong><br><code>let g = new adjacency_matrix();</code></p>
            <p><strong>Methods:</strong></p>

            <ul>
                <li><code>g.add_edge(i, j)</code>: add an unweighted edge from node <code>i</code> to <code>j</code>.
                </li>
                <li><code>g.contains_edge(i, j)</code>: Return whether there's an edge from <code>i</code> to
                    <code>j</code>.
                </li>
                <li><code>g.clear()</code>: Clear the graph.</li>
                <li><code>g.size()</code>: Return the number of nodes in the graph.</li>
                <li><code>g.size()</code>: Returns true if the graph is empty.</li>
                <li><code>g.edges()</code>: Return the number of edges in the graph.</li>
                <li><code>g.str()</code>: Returns the string representation of the adjacency matrix.</li>
            </ul>
            <p><strong>Example:</strong></p>
            <pre><code>
let g = new adjacency_matrix();
g.add_edge(i, j, 3.14);
            </code></pre>

            <h3 id="std_heap">PriorityQueue</h3>
            <p><strong>Summary:</strong> A binary heap implementation of a priority queue. Can be min or max based.</p>
            <p><strong>Constructor:</strong><br><code>let q = new heap();</code></p>
            <p><strong>Methods:</strong></p>
            <ul>
                <li><code>q.insert(value)</code>: Adds a value to the heap.</li>
                <li><code>q.poll()</code>: Removes and returns the highest-priority item.</li>
                <li><code>q.peek()</code>: Returns the top value without removing it.</li>
                <li><code>q.size()</code>: Returns the number of items.</li>
                <li><code>q.empty()</code>: Returns true if the queue is empty.</li>
                <li><code>q.clear()</code>: Prints the queue state.</li>
                <li><code>q.items()</code>: Returns the items in the heap as an iterable array.</li>
                <li><code>q.str()</code>: Returns the string representation of the heap.</li>
            </ul>
            <p><strong>Example:</strong></p>
            <pre><code>
let q = new heap();
q.insert(10);
q.insert(5);
let top = q.peek();
let removed = q.poll();
            </code></pre>

            <h3 id="std_treap">Treap</h3>
            <p><strong>Summary:</strong> A randomized balanced binary search tree using priorities and rotations.</p>
            <p><strong>Constructor:</strong><br><code>let t = new treap();</code></p>
            <p><strong>Methods:</strong></p>
            <ul>
                <li><code>t.insert(value)</code>: Inserts a new value.</li>
                <li><code>t.remove(value)</code>: Removes a value.</li>
                <li><code>t.contains(value)</code>: Checks membership.</li>
                <li><code>t.size()</code>: Returns number of nodes.</li>
                <li><code>t.height()</code>: Returns the tree height.</li>
                <li><code>t.min()</code>: Finds minimum value.</li>
                <li><code>t.max()</code>: Finds maximum value.</li>
                <li><code>t.clear()</code>: Removes all elements.</li>
                <li><code>t.empty()</code>: Returns true if the treap is empty.</li>
                <li><code>t.items()</code>: Returns the items in the treap as an iterable array (preorder).</li>
                <li><code>t.str()</code>: Returns the string representation of the treap.</li>
            </ul>
            <p><strong>Example:</strong></p>
            <pre><code>
let t = new treap();
t.insert(5);
t.insert(2);
t.insert(8);
            </code></pre>

            <h3 id="std_stack">Stack</h3>
            <p><strong>Summary:</strong> A LIFO stack for value pushing and popping.</p>
            <p><strong>Constructor:</strong><br><code>let s = new stack();</code></p>
            <p><strong>Methods:</strong></p>
            <ul>
                <li><code>s.push(value)</code>: Pushes a value.</li>
                <li><code>s.pop()</code>: Removes and returns the top value.</li>
                <li><code>s.peek()</code>: Returns the top value without removing it.</li>
                <li><code>s.size()</code>: Returns count of items.</li>
                <li><code>s.empty()</code>: Returns true if the stack is empty.</li>
                <li><code>s.clear()</code>: Clears the stack's contents.</li>
                <li><code>s.items()</code>: Returns the items in the stack as an iterable array.</li>
                <li><code>s.str()</code>: Returns the string representation of the stack.</li>
            </ul>
            <p><strong>Example:</strong></p>
            <pre><code>
let s = new stack();
s.push(10);
let x = s.pop();
            </code></pre>

            <h3 id="std_queue">Queue</h3>
            <p><strong>Summary:</strong> A FIFO queue with enqueue/dequeue operations.</p>
            <p><strong>Constructor:</strong><br><code>let q = new queue();</code></p>
            <p><strong>Methods:</strong></p>
            <ul>
                <li><code>q.enqueue(value)</code>: Adds to the end.</li>
                <li><code>q.push(value)</code>: Alias for enqueue.</li>
                <li><code>q.dequeue()</code>: Removes from the front.</li>
                <li><code>q.poll()</code>: Alias for dequeue.</li>
                <li><code>q.peek()</code>: Views the front item.</li>
                <li><code>q.size()</code>: Current length.</li>
                <li><code>q.empty()</code>: Returns true if the queue is empty.</li>
                <li><code>q.clear()</code>: Clears the queue's contents.</li>
                <li><code>q.items()</code>: Returns the items in the queue as an iterable array.</li>
                <li><code>q.str()</code>: Returns the string representation of the queue.</li>
            </ul>
            <p><strong>Example:</strong></p>
            <pre><code>
let q = new queue();
q.enqueue(5);
let x = q.dequeue();
            </code></pre>

            <h3 id="std_list">LinkedList</h3>
            <p><strong>Summary:</strong> A doubly linked list for bi-directional traversal.</p>
            <p><strong>Constructor:</strong><br><code>let l = new linked_list();</code></p>
            <p><strong>Methods:</strong></p>
            <ul>
                <li><code>l.append(value)</code>: Adds to tail.</li>
                <li><code>l.prepend(value)</code>: Adds to head.</li>
                <li><code>l.pop_head()</code>: Removes and returns the head.</li>
                <li><code>l.pop_tail()</code>: Removes and returns the tail.</li>
                <li><code>l.get(index)</code>: Gets and returns the value at the index.</li>
                <li><code>l.remove(index)</code>: Removes and returns the value at the index.</li>
                <li><code>l.discard(index)</code>: Removes the value at the index.</li>
                <li><code>l.peek_head()</code>: Returns the current head without removing.</li>
                <li><code>l.peek_tail()</code>: Returns the current tail without removing.</li>
                <li><code>l.clear()</code>: Empties the list.</li>
                <li><code>l.empty()</code>: Returns true if the list is empty.</li>
                <li><code>l.size()</code>: Number of nodes.</li>
                <li><code>l.items()</code>: Returns the items in the list as an iterable array.</li>
                <li><code>l.str()</code>: Returns the string representation of the list.</li>
            </ul>
            <p><strong>Example:</strong></p>
            <pre><code>
let l = new linked_list();
l.append(10);
let x = l.pop_head();
            </code></pre>

            <h3 id="std_deque">Deque</h3>
            <p><strong>Summary:</strong> A double-ended queue structure supporting push/pop operations from both ends.
            </p>
            <p><strong>Constructor:</strong><br><code>let d = new deque();</code></p>
            <p><strong>Methods:</strong></p>

            <ul>
                <li><code>d.push_tail(value)</code>: Add an element to the tail.</li>
                <li><code>d.push_head(value)</code>: Add an element to the head.</li>
                <li><code>d.pop_tail()</code>: Remove and return the element from the tail.</li>
                <li><code>d.pop_head()</code>: Remove and return the element from the head.</li>
                <li><code>d.peek_tail()</code>: Peek at the tail element.</li>
                <li><code>d.peek_head()</code>: Peek at the head element.</li>
                <li><code>d.size()</code>: Return the number of elements in the deque.</li>
                <li><code>d.empty()</code>: Returns true if the queue is empty.</li>
                <li><code>d.clear()</code>: Remove all elements from the deque.</li>
                <li><code>d.items()</code>: Returns the items in the deque as an iterable array.</li>
                <li><code>d.str()</code>: Returns the string representation of the queue.</li>
            </ul>

            <p><strong>Example:</strong></p>
            <pre><code>
let d = new deque();
d.push_tail(1);
d.push_head(2);
let front = d.pop_front();
            </code></pre>

            <h3 id="std_vector">Vector</h3>
            <p><strong>Summary:</strong> A mathematical vector structure supporting 2D, 3D, and 4D operations such as
                dot product, cross product, scaling, and projection.</p>

            <p><strong>Constructor:</strong><br><code>let v = new vector(1.0, 2.0, 3.0);</code><br>
                <code>let v = new vector([1.0, 2.0, 3.0]);</code>
            </p>

            <p><strong>Methods:</strong></p>
            <ul>
                <li><code>v.str()</code>: Returns the string representation of the vector.</li>
                <li><code>v.add(other)</code>: Adds another vector to this vector (in-place).</li>
                <li><code>v.sub(other)</code>: Subtracts another vector from this vector (in-place).</li>
                <li><code>v.dot(other)</code>: Computes the dot product with another vector.</li>
                <li><code>v.scale(scalar)</code>: Scales the vector by the given scalar (in-place).</li>
                <li><code>v.norm()</code>: Returns the Euclidean norm (magnitude) of the vector.</li>
                <li><code>v.normalize()</code>: Normalizes the vector to unit length (in-place).</li>
                <li><code>v.dim()</code>: Returns the number of components in the vector.</li>
                <li><code>v.project(onto)</code>: Projects this vector onto another (in-place).</li>
                <li><code>v.angle(other)</code>: Returns the angle (in radians) between this and another vector.</li>
                <li><code>v.cross(other)</code>: Computes the cross product (3D only) and mutates the vector.</li>
                <li><code>v.equals(other)</code>: Returns true if all components match.</li>
                <li><code>v.set(index, value)</code>: Sets the value at the given index.</li>
                <li><code>v.get(index)</code>: Returns the value at the given index.</li>
                <li><code>v.items()</code>: Returns an array of numeric elements in the vector.</li>
                <li><code>v.size()</code>: Returns the number of components (same as <code>dim()</code>).</li>
            </ul>

            <p><strong>Example:</strong></p>
            <pre><code>
let v = new vector(1.0, 2.0, 3.0);
v.add(new vector(3.0, 2.0, 1.0));
let norm = v.norm();
let s = v.str();
            </code></pre>

            <h3 id="std_matrix">Matrix</h3>
            <p><strong>Summary:</strong> A rectangular 2D array structure supporting common matrix operations such as
                addition, multiplication, scaling, inversion, and transposition. Only 2x2 to 4x4 square matrices support
                inversion.</p>

            <p><strong>Constructor:</strong><br>
                <code>let m = new matrix([1.0, 2.0], [3.0, 4.0]);</code><br>
                <code>let m = new matrix([[1.0, 2.0], [3.0, 4.0]]);</code><br>
                <code>let m = new matrix(3); // creates a 3x3 identity matrix</code>
            </p>

            <p><strong>Methods:</strong></p>
            <ul>
                <li><code>m.get(row, col)</code>: Returns the number at the given row and column.</li>
                <li><code>m.set(row, col, value)</code>: Sets the value at the given row and column.</li>
                <li><code>m.str()</code>: Returns a string representation of the matrix.</li>
                <li><code>m.add(other)</code>: Adds another matrix to this matrix (in-place).</li>
                <li><code>m.sub(other)</code>: Subtracts another matrix from this matrix (in-place).</li>
                <li><code>m.scale(scalar)</code>: Scales the matrix by a scalar (in-place).</li>
                <li><code>m.mul(other)</code>: Multiplies by another matrix or a vector. Returns a new result.</li>
                <li><code>m.transpose()</code>: Returns the transpose of the matrix.</li>
                <li><code>m.inverse()</code>: Returns the inverse of the matrix (only for 2x2, 3x3, 4x4).</li>
                <li><code>m.equals(other)</code>: Returns true if both matrices are element-wise equal.</li>
                <li><code>m.rows()</code>: Returns the number of rows.</li>
                <li><code>m.cols()</code>: Returns the number of columns.</li>
                <li><code>m.size()</code>: Returns the total number of elements.</li>
                <li><code>m.items()</code>: Returns a nested array of all the values.</li>
            </ul>

            <p><strong>Example:</strong></p>
            <pre><code>
let m = new matrix([1.0, 2.0], [3.0, 4.0]);
let value = m.get(0, 1);
m.set(1, 1, 9.0);
m.scale(0.5);
let transposed = m.transpose();
let stringified = m.str();
            </code></pre>

        </section>

    </main>

    <script>
        const root = document.documentElement;

        function setTheme(theme) {
            root.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);
        }

        function toggleTheme() {
            const current = root.getAttribute('data-theme');
            setTheme(current === 'dark' ? 'light' : 'dark');
        }

        (function applyStoredTheme() {
            const stored = localStorage.getItem('theme');
            if (stored) {
                setTheme(stored);
            } else {
                const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                setTheme(prefersDark ? 'dark' : 'light');
            }
        })();
    </script>
</body>

</html>